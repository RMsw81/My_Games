<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, height=device-height">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Applicazione Pygame</title>

    <link rel="prefetch" href="https://pygame-web.github.io/archives/0.9/pythonrc.py">
    <link rel="prefetch" href="https://pygame-web.github.io/archives/0.9/vt/xterm.js">
    <link rel="prefetch" href="https://pygame-web.github.io/archives/0.9/vt/xterm-addon-image.js">
    <link rel="icon" type="image/png" href="favicon.png" sizes="16x16">

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background-color: powderblue;
        }

        #status {
            display: inline-block;
            vertical-align: top;
            margin-top: 20px;
            margin-left: 30px;
            font-weight: bold;
            color: rgb(120, 120, 120);
        }

        #progress {
            height: 20px;
            width: 300px;
        }

        .emscripten {
            text-align: center;
            position: relative; /* Aggiunto per gestire il posizionamento */
            width: 100%; /* Aggiunto per il ridimensionamento */
            height: 100vh; /* Aggiunto per occupare l'altezza totale della finestra */
        }

        canvas.emscripten {
            border: 0;
            background-color: transparent;
            width: 100%;
            height: 100%;
            z-index: 5;
            position: absolute;
            top: 0;
            left: 0;
        }

        .topright {
            position: absolute;
            top: 0;
            right: 0;
        }

        .bottomright {
            position: absolute;
            top: 40%;
            right: 0;
        }

        .center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .trinfo {
            position: relative;
            right: 0;
            border: 1px solid black;
        }

        .framed {
            position: relative;
            top: 150px;
            right: 10px;
            border: 1px solid black;
        }
    </style>

    <script src="https://pygame-web.github.io/archives/0.9/browserfs.min.js"></script>
    <script src="https://pygame-web.github.io/archives/0.9/pythons.js" type="module" id="site" data-LINES="57" data-CONSOLE="25" data-python="python3.12" data-os="vtx,fs,snd,gui" async defer>
        #<!--
        print("""
        Loading p from p.apk
            Pygbag Version : 0.9.2
            Template Version : 0.9.0
            Python  : 3.12
            CDN URL : https://pygame-web.github.io/archives/0.9/
            Screen  : 1280x720
            Title   : p
            Folder  : p
            Authors : pgw
            SPDX-License-Identifier: cookiecutter.spdx
        """)

        # pixel dello schermo (reali, hardware)
        WIDTH = 1024  # 1280
        HEIGHT = 600  # 720

        # pixel di riferimento/idealizzati dello schermo
        REFX = 1980
        REFY = 1080

        def u(real, ref, v):
            if abs(v) < 0.9999999:
                result = int((float(real) / 100.0) * (v * 1000))
                return real - result if v < 0 else result
            return int((real / ref) * v)

        def ux(*argv):
            global WIDTH, REFX
            return sum(u(WIDTH, REFX, v) for v in argv)

        def uy(*argv):
            global HEIGHT, REFY
            return sum(u(HEIGHT, REFY, v) for v in argv)

        # non rinominare
        async def custom_site():
            import sys
            import asyncio
            import platform
            import json
            from pathlib import Path
            import embed

            platform.document.body.style.background = "#7f7f7f"

            import pygame

            def compose():
                pygame.display.update()
                window.chromakey(None, *screen.get_colorkey(), 40)

            pygame.init()
            pygame.font.init()

            screen = pygame.display.set_mode([ux(.100), uy(.100)], pygame.SRCALPHA, 32)
            screen.set_colorkey((0, 0, 0, 0), pygame.RLEACCEL)
            screen.fill((0, 0, 0, 0))

            compose()

            platform.window.transfer.hidden = True
            platform.window.canvas.style.visibility = "visible"

            apk = "p.apk"
            bundle = "p"
            appdir = Path(f"/data/data/{bundle}")  # /data/data/p
            appdir.mkdir()

            # montare apk
            cfg = {
                "io": "url",
                "type": "mount",
                "mount": {
                    "point": appdir.as_posix(),
                    "path": "/",
                },
                "path": f"/ => {appdir.as_posix()}",
            }

            track = platform.window.MM.prepare(apk, json.dumps(cfg))

            marginx = ux(.020)  # 20%
            marginy = uy(.045)  # 45%

            def pg_bar(pos):
                nonlocal marginx, marginy
                total = track.len or 10  # evita div0
                slot = ux(.060) / total  # 60%
                pygame.draw.rect(screen, (10, 10, 10), (marginx - ux(10), marginy - uy(10), (total * slot) + ux(20), uy(110)))
                pygame.draw.rect(screen, (0, 255, 0), (marginx, marginy, track.pos * slot, uy(90)))

            # attendere fino al montaggio dello zip + overlayfs è completo
            while not track.ready:
                pg_bar(track.pos)
                compose()
                await asyncio.sleep(.1)

            # riempi tutto nel caso fosse stato memorizzato nella cache e scaricato istantaneamente
            pg_bar(track.len)
            compose()

            # il preloader cambierà directory e lo premetterà a sys.path
            platform.run_main(PyConfig, loaderhome=appdir / "assets", loadermain=None)

            # attendere che il preloading sia completato
            while embed.counter() < 0:
                await asyncio.sleep(.1)

            main = appdir / "assets" / "main.py"

            # avviare la macchina di livello superiore asincrona e aggiungere una console.
            await TopLevel_async_handler.start_toplevel(platform.shell, console=window.python.config.debug)

            # ora che apk è montato abbiamo accesso alla cache dei caratteri
            __import__(__name__).__file__ = str(main)

            # ora creare un prompt
            fnt = pygame.sysfont.SysFont("freesans", uy(80))

            def ui_callback(pkg, error=None):
                nonlocal fnt
                prompt = fnt.render(f"{error}" if error else f"Impostazione [{pkg}] in corso", True, "black")
                pg_bar(track.len)
                screen.blit(prompt, (marginx + ux(80), marginy - uy(10)))
                compose()

            # test/attendere se è necessario un intervento dell'utente
            if not platform.window.MM.UME:
                prompt = fnt.render("Pronto per iniziare!", True, "blue")
                pg_bar(track.len)
                screen.blit(prompt, (marginx + ux(80), marginy - uy(10)))
                compose()
                print("""
                * In attesa di interazione dell'utente: per favore clicca/tocca la pagina *
                """)
                while not platform.window.MM.UME:
                    await asyncio.sleep(.1)

            # pulizia
            screen.fill((0, 0, 0, 0))
            pygame.display.flip()

            await shell.runpy(main, callback=ui_callback)

        import asyncio
        asyncio.run(custom_site())

        # INIZIO BLOCCO
        #
        # ora questa è la parte html che puoi (e dovresti) personalizzare
        # Non è obbligatorio: pygame-script quando legge la prima riga (chiamata
        # shebang) del codice sopra crea il set di widget assolutamente minimo
        # richiesto per funzionare con le regole predefinite
        #
        # non alterare quel blocco di commento; separa il codice python dal codice html
        # poiché è necessario per il corretto rendering dei widget e la creazione di
        # un contesto di caricamento. Se cambi il contenuto di quel blocco di commento,
        # non sarà più visibile un avviso di errore specifico in caso di problemi di
        # caricamento, ecc.
        #
        # QUESTO È TUTTO QUELLO CHE DEVI FARE, MA PUOI INSERIRE LE TUE MODIFICHE QUI IN BASSO.
        # QUESTO È UN TEMPLATE PER L'INIZIO DEL TUO PROGETTO.
        #
        # FINE BLOCCO
        #--><!--
        """)

    </script>
</head>
<body>
    <div class="emscripten">
        <canvas class="emscripten" id="canvas"></canvas>
        <div id="status">Caricamento...</div>
        <progress id="progress" value="0" max="100"></progress>
    </div>

    <script>
        // Memorizza un riferimento all'elemento di progresso
        const progressElement = document.getElementById('progress');

        // Controlla se l'oggetto 'MM' è definito
        if (window && window.MM) {
            // Monitora il progresso del download
            const monitorDownload = () => {
                const len = window.MM.track.len;  // Dimensione totale
                const pos = window.MM.track.pos;  // Posizione attuale
                const progress = (len > 0) ? (pos / len) * 100 : 0;  // Calcola la percentuale

                // Aggiorna l'elemento di progresso
                if (progressElement) {
                    progressElement.value = progress;
                }

                // Controlla se il download è completato
                if (len && pos >= len) {
                    clearInterval(downloadInterval);  // Ferma il monitoraggio
                    // Nascondi il progresso e mostra il canvas
                    progressElement.style.display = "none";
                    document.getElementById('status').innerText = 'Download completato!';
                }
            };

            // Imposta un intervallo per controllare il progresso del download
            const downloadInterval = setInterval(monitorDownload, 500);  // Controlla ogni 500ms
        }
    </script>
</body>
</html>
